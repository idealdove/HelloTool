


import sys
import os
import serial
import serial.tools.list_ports
import xml.etree.ElementTree as ET
from PyQt5 import QtWidgets
from PyQt5.QtGui import QIcon
from PyQt5.QtCore import QTimer
from PyQt5.QtGui import QIcon, QColor
from PyQt5.QtGui import QFont
from PyQt5.QtWidgets import QFileDialog


from functools import partial
from datetime import datetime

from ui_interface_debug import Ui_Form   # Import the UI class generated by Qt Designer


class MainWindow(QtWidgets.QWidget, Ui_Form):
    def __init__(self):
        super().__init__()
        self.setupUi(self)

        # font = QFont("calibri", 10)
        # self.rxTextEdit.setFont(font)
        # self.logTextEdit.setFont(font)
        # self.setStyleSheet("QPushButton { font-family: 'calibri'; font-size: 10pt; }")


        # inside MainWindow.__init__ after self.setupUi(self)
        self.xmlPathLabel = QtWidgets.QLabel(self)
        self.xmlPathLabel.setText("XML Path: (none)")
        self.rightLayout.addWidget(self.xmlPathLabel)   # put at the very bottom


        # windows icon setting
        self.setWindowIcon(QIcon("icon.ico"))

        # UART serial port object
        self.ser = None
        self.rx_buffer = bytearray()   # UART receive buffer

        self.prev_values = {}   # store previous values for change detection

        # Get absolute path of test.xml (same folder as main.py)
        base_dir = os.path.dirname(os.path.abspath(__file__))
        self.xml_path = os.path.join(base_dir, "test.xml")

        # Populate COM port list in ComboBox
        self.update_com_ports()

        # Parse XML and create buttons dynamically
        self.load_xml(self.xml_path)

        # Connect buttons
        self.openButton.clicked.connect(self.toggle_com)
        self.refreshButton.clicked.connect(self.update_com_ports)
        self.hexButton.clicked.connect(lambda: self.set_rx_mode("HEX"))
        self.asciiButton.clicked.connect(lambda: self.set_rx_mode("ASCII"))
        self.rx_mode = "HEX"   # default mode

        # Initialize status label
        self.set_status("Ready")

        # UART receive timer (polling every 500ms)
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.read_uart)
        self.timer.start(100)  ## 100ms period 

    ################################################################
    ## function group 
    ################################################################

    # def read_uart(self):
    #     """Check if UART has incoming data and display it"""
    #     if self.ser and self.ser.is_open and self.ser.in_waiting:
    #         try:
    #             data = self.ser.read(self.ser.in_waiting)
    #             # timestamp = datetime.now().strftime("%H:%M:%S")
    #             if self.rx_mode == "HEX":
    #                 text = " ".join(f"{b:02X}" for b in data)
    #             else:  # ASCII
    #                 text = data.decode(errors="ignore")
    #             # self.rxTextEdit.append(f"[{timestamp}] {text}")
    #             self.rxTextEdit.append(f"{text}")
    #         except Exception as e:
    #             self.rxTextEdit.append(f"[Error] {str(e)}")

    def read_uart(self):
        """Parse and display UART 38-byte packet"""
        if self.ser and self.ser.is_open and self.ser.in_waiting:
            try:
                data = self.ser.read(self.ser.in_waiting)
                self.rx_buffer.extend(data)

                # if len(data) >= 38:
                while len(self.rx_buffer) >= 38:

                    #find header 
                    if self.rx_buffer[0] == 0xFA and self.rx_buffer[1] == 0x4E:
                        packet = self.rx_buffer[:38]       # one complete packet
                        self.rx_buffer = self.rx_buffer[38:]  # remove processed
                        self.parse_packet(packet)          # custom parser
                    else:
                        # Header not aligned -> discard until we find FA 4E
                        self.rx_buffer.pop(0)

            except Exception as e:
                self.rxTextEdit.append(f"[Error] {str(e)}") 


    def parse_packet(self, data: bytes):
                out_lines = []

                # Helper: 2-byte unsigned integer
                def u16(lo, hi):
                    return (data[lo] << 8) | data[hi]

                # Helper: 1-byte unsigned integer
                def u8(idx):
                    return data[idx]

                # 0-1 Header
                out_lines.append(f"[0][1] Header = {data[0]:02X} {data[1]:02X}")

                # 2-3 PM1.0
                val = u16(2, 3)
                out_lines.append(f"[2][3] PM1.0 = {val} ({val:#06x})")

                # 4-5 PM2.5
                val = u16(4, 5)
                out_lines.append(f"[4][5] PM2.5 = {val} ({val:#06x})")

                # 6-7 PM10
                val = u16(6, 7)
                out_lines.append(f"[6][7] PM10 = {val} ({val:#06x})")

                # 8-9 AQI Value
                val = u16(8, 9)
                out_lines.append(f"[8][9] AQI Value = {val} ({val:#06x})")

                # 10-11 FAN RPM
                val = u16(10, 11)
                out_lines.append(f"[10][11] FAN RPM = {val} ({val:#06x})")

                # 12 Last Input Key & Filter Info (bit flags)
                b12 = u8(12)
                out_lines.append(f"[12] Last Input Key/Filter Info = {b12} (0x{b12:02X})")
                out_lines.append(f"...[bit0] FAN Mode Key = {'ON' if b12 & 0x01 else 'OFF'}")
                out_lines.append(f"...[bit1] Display Key = {'ON' if b12 & 0x02 else 'OFF'}")
                out_lines.append(f"...[bit2] Power Key = {'ON' if b12 & 0x04 else 'OFF'}")
                out_lines.append(f"...[bit3] Filter Key = {'ON' if b12 & 0x08 else 'OFF'}")
                out_lines.append(f"...[bit5] Filter Switch Open = {'ON' if b12 & 0x20 else 'OFF'}")
                out_lines.append(f"...[bit6] Filter used time over = {'ON' if b12 & 0x40 else 'OFF'}")

                # 13 FAN speed
                val = u8(13)
                fan_map = {
                    1: "Auto",
                    2: "Manual 1x",
                    4: "Manual 2x",
                    8: "Manual 3x",
                    16: "Manual 4x",
                }
                fan = fan_map.get(val, "Unknown")

                out_lines.append(f"[13] FAN Speed = {fan} ({val:#04x})")

                # 14 AQI Grade
                val = u8(14)

                # Mapping value to color name (with number)
                grade_map = {
                    1: "Blue",
                    2: "Green",
                    3: "Amber",
                    4: "Red"
                }
                color = grade_map.get(val, "Unknown")

                # Example: [14] AQI Grade = Blue(1) (0x01)
                out_lines.append(f"[14] AQI Grade = {color} (0x{val:02X})")
                # out_lines.append(f"[14] AQI Grade = {val} ({val:#04x})")

                # 17-18 Filter Used Time (hour)
                val = u16(17, 18)
                out_lines.append(f"[17][18] Filter Used Time = {val} h")

                # 19-27 F/W Version (ASCII string)
                fw_ver = data[19:28].decode(errors="ignore")
                out_lines.append(f"[19-27] F/W Version = {fw_ver}")

                # 28-29 Temperature
                val = u16(28, 29)
                out_lines.append(f"[28][29] Temperature = {val} ({val:#06x})")

                # 30 Command Status (bit flags)
                b30 = u8(30)
                out_lines.append(f"[30] Command Status = {b30} (0x{b30:02x})")
                out_lines.append(f"...[bit0] Power On Status = {'ON' if b30 & 0x01 else 'OFF'}")
                out_lines.append(f"...[bit1] LED Display On Status = {'ON' if b30 & 0x02 else 'OFF'}")
                out_lines.append(f"...[bit2] All LED On Status = {'ON' if b30 & 0x04 else 'OFF'}")
                out_lines.append(f"...[bit3] Factory Init = {'ON' if b30 & 0x08 else 'OFF'}")

                # 31 LED Brightness
                val = u8(31)
                out_lines.append(f"[31] LED Brightness = {val} ({val:#04x})")

                # 32-35 Touch IC Version (ASCII string)
                touch_ic = data[32:36].decode(errors="ignore")
                out_lines.append(f"[32-35] Touch IC Version = {touch_ic}")

                # 36-37 Checksum
                val = u16(36, 37)
                out_lines.append(f"[36][37] Checksum = {val} ({val:#06x})")

                # --- Display with color highlighting for changes ---
                self.rxTextEdit.clear()
                for line in out_lines:
                    if "=" in line:
                        key, value = line.split("=", 1)
                        key = key.strip()
                        value = value.strip()

                        # Change detection
                        if key in self.prev_values:
                            if self.prev_values[key] != value:
                                # Value changed -> red
                                # self.rxTextEdit.setTextColor(QtGui.QColor("red"))
                                self.rxTextEdit.setTextColor(QColor("red"))
                            else:
                                # Same value -> black
                                # self.rxTextEdit.setTextColor(QtGui.QColor("black"))
                                self.rxTextEdit.setTextColor(QColor("black"))
                        else:
                            # First value -> black
                            # self.rxTextEdit.setTextColor(QtGui.QColor("black"))
                            self.rxTextEdit.setTextColor(QColor("black"))

                        self.rxTextEdit.append(f"{key} = {value}")
                        self.prev_values[key] = value
                    else:
                        # Non-value line (flags, etc.)
                        # self.rxTextEdit.setTextColor(QtGui.QColor("black"))
                        self.rxTextEdit.setTextColor(QColor("black"))
                        self.rxTextEdit.append(line)

                # Reset color to default (black)
                # self.rxTextEdit.setTextColor(QtGui.QColor("black"))
                self.rxTextEdit.setTextColor(QColor("black"))

            #     else:
            #         self.rxTextEdit.append("Incomplete packet")
            #         # Debugging log
            #         length = len(data)
            #         hex_dump = " ".join(f"{b:02X}" for b in data)
            #         # self.set_status(f"Sent: {name} - {cmd_hex}")
            #         self.set_status(f"[DEBUG] Incomplete packet: length={length}")
            #         self.set_status(f"[DEBUG] Raw Data: {hex_dump}")

            # except Exception as e:
            #     self.rxTextEdit.append(f"[Error] {str(e)}")



    def set_rx_mode(self, mode):
        """Set receive display mode (HEX or ASCII)"""
        self.rx_mode = mode
        if mode == "HEX":
            self.hexButton.setChecked(True)
            self.asciiButton.setChecked(False)
        else:
            self.hexButton.setChecked(False)
            self.asciiButton.setChecked(True)
        self.set_status(f"UART display mode: {mode}")


    def set_status(self, message):
        """Update status label text"""
        self.statusLabel.setText(message)
        print(message)

    def update_com_ports(self):
        """Scan available COM ports and update ComboBox"""
        self.portComboBox.clear()
        ports = serial.tools.list_ports.comports()
        for port in ports:
            self.portComboBox.addItem(port.device)
        if self.portComboBox.count() == 0:
            self.portComboBox.addItem("No Ports Found")
        self.set_status("COM ports updated")


    # def load_xml(self, filename):
    #     """Parse XML file and create buttons for each command"""
    #     if not os.path.exists(filename):
    #         QtWidgets.QMessageBox.critical(
    #             self,
    #             "XML File Error",
    #             f"Cannot find the XML file:\n{filename}",
    #         )
    #         self.set_status("XML file not found")
    #         return

    #     try:
    #         tree = ET.parse(filename)
    #         root = tree.getroot()
    #     except Exception as e:
    #         QtWidgets.QMessageBox.critical(
    #             self,
    #             "XML Parse Error",
    #             f"Failed to parse XML file:\n{filename}\n\nError: {str(e)}",
    #         )
    #         self.set_status("XML parse error")
    #         return

    #     cmd_list = root.find("CmdList")
    #     if cmd_list is None:
    #         QtWidgets.QMessageBox.warning(
    #             self,
    #             "XML Warning",
    #             "No <CmdList> section found in XML file.",
    #         )
    #         self.set_status("No CmdList in XML")
    #         return

    #     # 2-column layout placement
    #     row, col = 0, 0
    #     for i, cmd_info in enumerate(cmd_list.findall("CmdInfo")):
    #         name = cmd_info.find("Name").text
    #         value = cmd_info.find("Cmd").text.strip()

    #         btn = QtWidgets.QPushButton(name)
    #         btn.clicked.connect(lambda checked, n=name, v=value: self.send_cmd(n, v))

    #         self.buttonLayout.addWidget(btn, row, col)

    #         col += 1
    #         if col >= 2:   # wrap to next row after 2 columns
    #             col = 0
    #             row += 1

    #     self.set_status("XML commands loaded")


    def load_xml(self, filename):
        """Parse XML file and create buttons for each command"""
        if not os.path.exists(filename):
            # Ask user to select XML file via file dialog
            options = QFileDialog.Options()
            options |= QFileDialog.ReadOnly
            file_path, _ = QFileDialog.getOpenFileName(
                self,
                "Select XML File",
                "",
                "XML Files (*.xml);;All Files (*)",
                options=options,
            )
            if not file_path:  # user canceled
                QtWidgets.QMessageBox.critical(
                    self,
                    "XML File Error",
                    f"Cannot find or select XML file:\n{filename}",
                )
                self.set_status("XML file not found")
                return
            else:
                filename = file_path
                self.xml_path = filename   # update xml_path

        try:
            tree = ET.parse(filename)
            root = tree.getroot()
        except Exception as e:
            QtWidgets.QMessageBox.critical(
                self,
                "XML Parse Error",
                f"Failed to parse XML file:\n{filename}\n\nError: {str(e)}",
            )
            self.set_status("XML parse error")
            return

        cmd_list = root.find("CmdList")
        if cmd_list is None:
            QtWidgets.QMessageBox.warning(
                self,
                "XML Warning",
                "No <CmdList> section found in XML file.",
            )
            self.set_status("No CmdList in XML")
            return

        # 2-column layout placement
        row, col = 0, 0
        for i, cmd_info in enumerate(cmd_list.findall("CmdInfo")):
            name = cmd_info.find("Name").text
            value = cmd_info.find("Cmd").text.strip()

            btn = QtWidgets.QPushButton(name)
            btn.clicked.connect(lambda checked, n=name, v=value: self.send_cmd(n, v))

            self.buttonLayout.addWidget(btn, row, col)

            col += 1
            if col >= 2:   # wrap to next row after 2 columns
                col = 0
                row += 1

        abs_path = os.path.abspath(filename)
        self.xmlPathLabel.setText(f"XML Path : {abs_path}")

        self.set_status("XML commands loaded")


    def toggle_com(self):
        """Toggle COM port open/close"""
        if self.ser and self.ser.is_open:
            self.ser.close()
            self.ser = None
            self.openButton.setText("Open COM")

            timestamp = datetime.now().strftime("%H:%M:%S")
            log_entry = f"[{timestamp}] COM Closed"
            self.set_status("COM Closed")
            self.log_command(log_entry)

        else:
            selected_port = self.portComboBox.currentText()
            if "No Ports" in selected_port:
                QtWidgets.QMessageBox.warning(
                    self,
                    "COM Port Error",
                    "No available COM ports.",
                )
                self.set_status("No COM ports available")
                return
            try:
                self.ser = serial.Serial(port=selected_port, baudrate=115200, timeout=1)
                self.openButton.setText("Close COM")

                timestamp = datetime.now().strftime("%H:%M:%S")
                log_entry = f"[{timestamp}] {selected_port} Opened"
                self.set_status(f"{selected_port} Opened")
                self.log_command(log_entry)

            except Exception as e:
                QtWidgets.QMessageBox.critical(
                    self,
                    "COM Open Error",
                    f"Failed to open {selected_port}\n\nError: {str(e)}",
                )
                self.set_status("COM open failed")
    

    def send_cmd(self, name, cmd_hex):
        """Send HEX command via UART"""
        if self.ser and self.ser.is_open:
            try:
                data = bytes.fromhex(cmd_hex)
                self.ser.write(data)

                # Timestamp
                timestamp = datetime.now().strftime("%H:%M:%S")
                log_entry = f"[{timestamp}] {name} - {cmd_hex}"

                self.set_status(f"Sent: {name} - {cmd_hex}")
                self.log_command(log_entry)
            except Exception as e:
                QtWidgets.QMessageBox.critical(
                    self,
                    "Send Error",
                    f"Failed to send command:\n{name} - {cmd_hex}\n\nError: {str(e)}",
                )
                self.set_status("Send error")
        else:
            QtWidgets.QMessageBox.warning(
                self,
                "Serial Not Open",
                "Serial port is not open. Please open COM port first.",
            )
            self.set_status("Serial not open")

    def closeEvent(self, event):
        """Called when the window is closed"""
        if self.ser and self.ser.is_open:
            self.ser.close()
            print("COM port closed on exit.")
        event.accept()



    
    def log_command(self, message):
        """Append command log to the log text box"""
        self.logTextEdit.append(message)

    ################################################################

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())


