# import sys
# import serial
# import serial.tools.list_ports
# import threading
# from datetime import datetime

# from PyQt5 import QtWidgets
# from PyQt5.QtSerialPort import QSerialPortInfo
# from PyQt5.QtCore import QTimer
# from PySide6 import QtWidgets, QtCore
# import pyqtgraph as pg

# from ui_interface import Ui_Form   # Import the UI class generated by pyuic5

import sys
import serial
import serial.tools.list_ports
import threading
from datetime import datetime

from PySide6 import QtWidgets, QtCore
from PySide6.QtSerialPort import QSerialPortInfo
from PySide6.QtCore import QTimer
import pyqtgraph as pg

from ui_interface import Ui_Form


class MainWindow(QtWidgets.QWidget, Ui_Form):
    def __init__(self, *args, **kwargs):
        super(MainWindow, self).__init__(*args, **kwargs)

        # Initialize UI from ui_monitoring.py
        self.setupUi(self)

        # Serial port object
        self.ser = None
        self.receive_thread = None
        self.running = False

        # Data variables
        self.aqi_value = 0
        self.rpm = 0
        self.time_index = []
        self.aqi_data = []
        self.rpm_data = []

        ########################################################
        # Plotting setup
        ########################################################
        self.Graph1.setBackground('w')  # White background
        self.Graph2.setBackground('w')  # White background

        self.curve_aqi = self.Graph1.plot(pen='g', name="AQI")   # Green curve for AQI
        self.curve_rpm = self.Graph2.plot(pen='b', name="RPM")   # Blue curve for RPM

        # Enable mouse interactions
        self.Graph1.setMouseEnabled(x=True, y=True)
        self.Graph2.setMouseEnabled(x=True, y=True)

        # Initial Y-axis ranges
        self.Graph1.setYRange(0, 50)       # AQI: 0 ~ 50
        self.Graph2.setYRange(1000, 3500)  # RPM: 1000 ~ 3500



        # Timer for periodic graph update
        self.timer = QTimer()
        self.timer.setInterval(500)  # 0.5 sec interval
        self.timer.timeout.connect(self.update_graph)
        # self.timer.start()   # Start only after COM port is open



        self.counter = 0

        ########################################################
        # Serial port handling
        ########################################################
        self.populate_serial_ports()

        # Button will toggle open/close
        self.pushButton_open.clicked.connect(self.comport_open_command)

        

    ########################################################
    # Serial port handling functions 
    ########################################################
    def populate_serial_ports(self):
        """Populate the ComboBox with available serial ports."""
        self.comboBox_port.clear()
        port_list = QSerialPortInfo.availablePorts()
        for port_info in port_list:
            self.comboBox_port.addItem(port_info.portName())


    def comport_open_command(self):
        """Toggle serial port connection when Open button is clicked."""
        if self.ser and self.ser.is_open:
            # Close port
            self.running = False
            if self.receive_thread and self.receive_thread.is_alive():
                self.receive_thread.join(timeout=1.0)
            self.ser.close()
            print("Serial port closed")

            # Stop graph updates
            self.timer.stop()

            self.pushButton_open.setText("Open")
        else:
            # Open port
            self.search_and_connect_comport()
            if self.ser and self.ser.is_open:
                # Start graph updates
                self.timer.start()

                self.pushButton_open.setText("Close")




    def search_and_connect_comport(self):
        """Search available ports and connect to the selected one."""
        ports = serial.tools.list_ports.comports()
        available_ports = [port.device for port in ports]

        if not available_ports:
            QtWidgets.QMessageBox.critical(self, "Error", "No available serial ports found.")
            return

        if len(available_ports) == 1:
            selected_port = available_ports[0]
        else:
            selected_port = self.comboBox_port.currentText()

        if selected_port in available_ports:
            try:
                # Close previous connection if open
                if self.ser and self.ser.is_open:
                    self.ser.close()
                # Open new connection
                self.ser = serial.Serial(selected_port, baudrate=115200, timeout=1)
                if self.ser.is_open:
                    print(f"Connected to {selected_port}")
                    self.start_receiving()
            except serial.SerialException as e:
                QtWidgets.QMessageBox.critical(self, "Error", f"Failed to connect: {e}")


    def start_receiving(self):
        """Start a background thread to receive serial data."""
        self.running = True
        self.receive_thread = threading.Thread(target=self.receive_data, daemon=True)
        self.receive_thread.start()
        

    def receive_data(self):
        """Thread function to continuously read serial data."""
        if self.ser:
            self.ser.timeout = 0.1

        while self.running:
            if self.ser and self.ser.is_open:
                try:
                    header = self.ser.read(2)  # Read first 2 bytes
                    if header and header[0] == 0xFA and header[1] == 0x4E:
                        data = self.ser.read(36)  # Read remaining 36 bytes
                        if data:
                            byte_array = [header[i] for i in range(2)] + [data[i] for i in range(36)]
                            current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

                            # Example: extract AQI and RPM values
                            self.aqi_value = (byte_array[8] << 8) | byte_array[9]
                            self.rpm = (byte_array[10] << 8) | byte_array[11]

                            # Update UI (LCD displays)
                            self.lcdNumber_aqiValue.display(self.aqi_value)
                            self.lcdNumber_rpm.display(self.rpm)

                            print(f"[{current_time}] AQI: {self.aqi_value}, RPM: {self.rpm}")

                except serial.SerialException as e:
                    print(f"Failed to receive data: {e}")
                    break
        print("Receive thread terminated")

    ########################################################
    # Plot updating
    ########################################################
    def update_graph(self):
        """Update the plot with new data."""
        self.counter += 1
        self.time_index.append(self.counter)
        self.aqi_data.append(self.aqi_value)
        self.rpm_data.append(self.rpm)

        # Update AQI plot
        self.curve_aqi.setData(self.time_index, self.aqi_data)

        # If AQI exceeds 50, expand y-axis automatically
        if max(self.aqi_data, default=0) > 50:
            self.Graph1.enableAutoRange(axis=pg.ViewBox.YAxis, enable=True)
        else:
            self.Graph1.setYRange(0, 50)

        # Update RPM plot (fixed range 1000 ~ 3500)
        self.curve_rpm.setData(self.time_index, self.rpm_data)
        self.Graph2.setYRange(1000, 3500)



########################################################
# Main function
########################################################
def main():
    app = QtWidgets.QApplication(sys.argv)
    win = MainWindow()
    win.show()
    sys.exit(app.exec())



if __name__ == '__main__':
    main()


